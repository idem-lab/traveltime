---
title: "`traveltime`: an R package to calculate walking and motorised travel time from user-specified locations"
format:
  #md: default
  html:
    keep-md: true
    fig-height: 4
    fig-align: center
    fig-format: png
    dpi: 300
tags: 
  - R
  - geographic information systems
  - spatial analysis
authors:
  - name: Gerard E. Ryan
    orcid: 0000-0003-0183-7630
    corresponding: true
    affiliation: "1, 2"
  - name: Nicholas Tierney
    orcid: 0000-0003-1460-8722
    affiliation: "1, 3"
  - name: Nick Golding
    orcid: 0000-0001-8916-5570
    affiliation: "1, 4"
  - name: Daniel J. Weiss
    orcid: 0000-0002-6175-5648
    affiliation: "1, 3"
affiliations:
 - name: The Kids Research Institute Australia, Nedlands 6009 WA, Australia
   index: 1
 - name: Melbourne School of Population and Global Health, University of Melbourne, 3010, VIC, Australia
   index: 2
 - name: Curtin University, Bentley, WA, Australia
   index: 3
 - name: University of Western Australia, WA, Australia
   index: 4
date: In prep 2025
bibliography: paper.bib
---

```{r}
#| label: setup
#| include: false
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

# Summary

Understanding and mapping the time to travel among locations is useful for many activities from urban planning [@zahavi1974traveltime] to public health [@hulland2019travel; @weiss2020global] and myriad others [@nelson2019suite]. Here we present a software package --- `traveltime` --- written in and for the language R [@Rref]. `traveltime` enables a user to create a map of the motorised or walking travel time over an area of interest from a user-specified set of geographic coordinates. The result is a raster of the area of interest where the value in each cell is the lowest travel time in minutes to any of the specified locations. We envisage these maps as having diverse applications including: estimating sampling bias in species occurrence data [@dennis2000bias, @reddy2003geographical], mapping electric vehicle charger accessibility [@falchetta2021electric], or understanding access to agricultural processing facilities [@zhao2023replanting].

The work-flow requires two steps:

-   preparing a 'friction surface' for the area of interest, and then
-   calculating travel time over that surface for the points of interest.

`traveltime` provides a spatial interface using object classes from the `terra` package [@terra]. It accepts points as `matrix`, `data.frame`, or `SpatVector` class objects; and the area of interest as an extent in the form of a `numeric`, `SpatExtent`, `SpatVector`, or `SpatRaster` object; and returns the result as a `SpatRaster` object. Internally, `traveltime` uses a number of existing R packages to perform specific operations. `gdistance` [@gdistance2017] is used to calculate the minimum least-cost-distance for each cell from the points of interest. The travel time is calculated as movement over any 'friction surface' the user supplies. To provide easy access to the existing friction surfaces generated by @weiss2020global. `traveltime` uses the package `malariaAtlas` to access friction surfaces for the desired extent, potentially saving the user downloading global surfaces and cropping them separately.

`traveltime` is available from [R-Universe](https://idem-lab.r-universe.dev/traveltime) and [GitHub](https://github.com/idem-lab/traveltime), and has reference documents at <https://idem-lab.github.io/traveltime/>. Although this article is intended to be the key reference for the `traveltime` package, we suggest citations of the package should be accompanied by citing the underlying work [@weiss2018global; @weiss2020global] as well.

# Statement of need

Global maps of travel time to cities [@weiss2018global; @nelson2019suite] and health care facilities [@hulland2019travel; @weiss2020global] have generated significant interest and use[^1], and the city data set of @nelson2019suite is available to R users through the widely-used `geodata` package [@geodata]. There is clear demand for these type of products.

[^1]: Collectively >1600 citations per Google Scholar at the 28th of January 2025.

@weiss2020global made their code available as an R script to allow for reproduction and extension of their analyses (<https://malariaatlas.org/wp-content/uploads/2022/11/R_generic_accessibilty_mapping_script_2020-1.txt> ). To further enable extension of this work, here we have developed an R package based on that code to seamlessly calculate the travel time from any arbitrary set of locations.

Other R packages provide superficially similar though fundamentally different functionality. A gaggle of R packages provide interfaces to the [TravelTime.com](https://www.TravelTime.com) API [@traveltimeapi; @traveltimeR; @rtraveltime; @traveltime_gh]. The TravelTime.com platform provides travel time and routes between pairs of locations, and 'isochron' polygons --- areas reachable within a given time from a given location. The isochron polygons are most comparable to what the `traveltime` package calculates, though each calculation is for a single point location and specified maximum travel time, and the result provides a maximum reachable extent for a specified time, rather than gradation across a landscape for multiple points. TravelTime.com cannot provide a single result surface for time to the nearest of a group of points, and continuous time scale without extensive repeated iteration for all combinations of time and points, plus additional calculation of the minimum value for each cell from all points. Furthermore, TravelTime.com requires access keys, a paid subscription beyond a short free period, and caps queries, which add considerable friction to the use of this resource.

With `traveltime`, we provide free and open source software to estimate motorised or walking travel time from any number of user-supplied locations, across a complete area of interest.

# Example: walking from public transport in Singapore

In this example we wish to calculate the walking travel time from the nearest mass transit station across the island nation of Singapore --- specifically Mass Rapid Transit (MRT) and Light Rail Transit (LRT) stations --- and create a map of this.

## Prepare the data and download friction surface

For this excercise, we need two items of data:

-   our area of interest --- in this case a map of Singapore, and
-   our points to calculate travel time from --- here the locations of Singapore's MRT and LRT stations.

We can download a national-level polygon of Singapore from the GADM [@gadm] database using the `geodata` package [@geodata]. Here we download only the national boundary (`level = 0`) and at a low resolution (`resolution = 2`). Our boundary `singapore_shapefile` is a `SpatVector` class object.

```{r}
#| label: get-basemap
library(terra)
library(geodata)

singapore_shapefile <- gadm(
  country = "Singapore",
  level = 0,
  path = tempdir(),
  resolution = 2
)

singapore_shapefile
```


The `stations` data set included in the `traveltime` package is a 563 row, 2 column `matrix` containing the longitude (`x`) and latitude (`y`) of all LRT and MRT station exits in Singapore from @singdata:

```{r}
#| label: show-stations
library(traveltime)
head(stations)
```

Now that we have the two items of data that we require, the next step is to download a friction surface for our area of interest. We can pass in our basemap `singapore_shapefile`, a `SpatVector`, directly as the `extent`. We're interested in walking time from a station, so we'll download the walking friction surface by specifying `surface = "walk2020"`. (Alternatively, we could use `surface = "motor2020"` for motorised travel if that were of interest.) We're also only interested in walking *on land* so we then mask out areas outside of `singapore_shapefile`, that are within the extent of the friction surface raster:

```{r}
#| label: download-friction-surface
#| echo: true
#| output: false
friction_singapore <- get_friction_surface(
    surface = "walk2020",
    extent = singapore_shapefile
  )|> 
  mask(singapore_shapefile)
```

Thus we have our friction surface as a `SpatRaster`:

```{r }
#| label: show-friction-surface-raster
friction_singapore
```

Below we plot the friction surface raster `friction_singapore`, with the vector boundary `singapore_shapefile` as a grey line, and `stations` as grey points (Figure @fig-data). Higher values of friction indicate more time travelling across a given cell.

```{r}
#| label: fig-data
#| echo: false
#| fig-cap: "Friction surface raster of Singapore, showing Singapore boundary
#|   in grey, and station locations as grey points."
library(tidyterra)
library(ggplot2)

ggplot() +
  geom_spatraster(
    data = friction_singapore
  ) +
  geom_spatvector(
    data = singapore_shapefile,
    fill = "transparent",
    col = "grey50"
  ) +
  geom_point(
    data = stations,
    aes(
      x = x,
      y = y
    ),
    col = "grey60",
    size = 0.5
  ) +
  scale_fill_viridis_c(
    option = "A",
    na.value = "transparent",
    direction = -1
  ) +
  labs(
    fill = "Friction",
    x = element_blank(),
    y = element_blank()
  ) +
  theme_minimal()


```

## Calculate and plot the travel time

With all the data collected, the function `calculate_travel_time()` takes the friction surface `friction_singapore()` and the locations of interest `stations`, and returns a `SpatRaster` of walking time in minutes to each cell from the nearest station:

```{r}
#| label: calculate-result
travel_timesingapore <- calculate_travel_time(
  friction_surface = friction_singapore,
  points = stations
)

travel_timesingapore
```

We present the resulting calculated travel times in Figure @fig-result. Note that the results in `travel_timesingapore` include infinite (`Inf`) values. In Figure @fig-data, the islands to the south and north-east are shown as filled cells, but unconnected with the mainland. The raster cells for these islands appear absent in Figure @fig-result. Because they are not connected to any cells with a station, the calculated travel time is infinite, and so these cells do not appear in Figure @fig-result.

```{r}
#| label: fig-result
#| echo: false
#| fig-cap: "Map of walking travel time in Singapore, in minutes from 
#|   nearest MRT or LRT station."
ggplot() +
  geom_spatraster(
    data = travel_timesingapore
  ) +
  scale_fill_viridis_c(
    option = "A",
    direction = -1,
    na.value = "transparent"
  ) +
  theme_minimal() +
  labs(fill = "Minutes") +
  geom_spatvector(
    data = singapore_shapefile,
    fill = "transparent",
    col = "grey20"
  )
```

# Opportunities for future development

The `traveltime` package is immediately suitable to a range of applications where travel to custom locations is of interest. Nonetheless, we see opportunities to build the package utility into the future through two mechanisms: (1) capability to better distribute a wider range friction surfaces, and (2) additional methods to handle large spatial extents.

Firstly, `traveltime` currently has access to walking and motorised friction surfaces for 2020, both at 30 arc-second resolution[^2]. As landscapes are not dynamic, it may be useful to incorporate updated versions of these friction surfaces if and when they are available, though this is likely to occur first through `malariaAtlas`. Furthermore, although the resolution of these data is likely to be suitable for larger landscape foci, higher resolution data may be helpful for more locally focussed analyses. For instance, although the example here was chosen for it's simplicity and low computational demands, a ~1 km^2^ cell size is a relatively large area to walk across, and thus actual waking times are likely to vary significantly within each cell. We note though that the capability to calculate travel time over any friction surface exists presently, it is only the availability of additional surfaces that is presently restrictive.

[^2]: Approximately 0.008333 decimal degrees, or just below 1 km^2^ at the equator

At the other end of the scale, the calculations can require relatively large amounts of onboard memory for analyses over large landscapes (e.g. one analyses over Africa required \~ 72 GB RAM). Developing methods to handle large landscapes either with less memory or via cloud resources would be helpful to make such analyses accessible to those without access to larger computing resources.

# Acknowledgements

This work was supported, in whole or in part, by the Bill & Melinda Gates Foundation [INV-021972]. The conclusions and opinions expressed in this work are those of the author(s) alone and shall not be attributed to the Foundation. Under the grant conditions of the Foundation, a Creative Commons Attribution 4.0 License has already been assigned to the Author Accepted Manuscript version that might arise from this submission. Please note works submitted as a preprint have not undergone a peer review process.


# References
