---
title: "`traveltime`: an R package to calculate travel time across a landscape from user-specified locations"
format:
  plos-pdf:
    keep-tex: true
    fig-height: 4
    fig-align: center
    fig-format: png
    dpi: 300   
tags: 
  - R
  - geographic information systems
  - spatial analysis
authors:
  - name: Gerard E. Ryan
    orcid: 0000-0003-0183-7630
    corresponding: true
    affiliations:
      - The Kids Research Institute Australia, Nedlands 6009 WA, Australia
      - Melbourne School of Population and Global Health, University of Melbourne, 3010, VIC, Australia
  - name: Nicholas Tierney
    orcid: 0000-0003-1460-8722
    affiliations:
      - The Kids Research Institute Australia, Nedlands 6009 WA, Australia
      - Curtin University, Bentley, WA, Australia
  - name: Nick Golding
    orcid: 0000-0001-8916-5570
    affiliations:
      - University of Western Australia, WA, Australia
      - The Kids Research Institute Australia, Nedlands 6009 WA, Australia
  - name: Daniel J. Weiss
    orcid: 0000-0002-6175-5648
    affiliations:
      - The Kids Research Institute Australia, Nedlands 6009 WA, Australia
      - Curtin University, Bentley, WA, Australia
date: In prep 2025
bibliography: paper.bib
---

```{r}
#| label: setup
#| include: false
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

# Summary

Understanding and mapping the time to travel among locations is useful for many activities from urban planning [@zahavi1974traveltime] to public health [@hulland2019travel; @weiss2020global] and myriad others [@nelson2019suite]. Here we present a software package --- `traveltime` --- written in and for the language R [@Rref]. `traveltime` enables a user to create a map of the motorised or walking travel time over an area of interest from a user-specified set of geographic coordinates. The result is a raster of the area of interest where the value in each cell is the lowest travel time in minutes to any of the specified locations. We envisage this software having diverse applications including: estimating sampling bias in species occurrence data [@dennis2000bias; @reddy2003geographical], mapping electric vehicle charger accessibility [@falchetta2021electric], allocating public defibrillators [@tierney2018novel], setting rehabilitation districts for stroke patients [@padgham2019introduction], or understanding access to agricultural processing facilities [@zhao2023replanting].

The work-flow requires two steps:

-   preparing a 'friction surface' for the area of interest, and then
-   calculating travel time over that surface for the points of interest.

`traveltime` provides a spatial interface using object classes from the `terra` package [@terra]. It accepts points as `matrix`, `data.frame`, or `SpatVector` class objects; and the area of interest as an extent in the form of a `numeric`, `SpatExtent`, `SpatVector`, or `SpatRaster` class object; and returns the result as a `SpatRaster` class object. The travel time is calculated as movement over a resistance 'friction surface' [@gdistance2017]. To provide easy access to the existing friction surfaces generated by Weiss et al. [@weiss2020global], `traveltime` uses the package `malariaAtlas` to allow users to access friction surfaces for the area of interest; though users can also supply any other friction surfaces to `traveltime`. Functionality from `gdistance` [@gdistance2017] is also used internally to calculate the minimum least-cost-distance for each cell from the points of interest. 

`traveltime` is available from [R-Universe](https://idem-lab.r-universe.dev/traveltime) and [GitHub](https://github.com/idem-lab/traveltime), and has reference documents at <https://idem-lab.github.io/traveltime/>. Although this article is intended to be the key reference for the `traveltime` package, we suggest citations of the package should be accompanied by citing the underlying methodological work [@weiss2018global; @weiss2020global] as well.

# Statement of need

Global maps of travel time to cities [@weiss2018global; @nelson2019suite] and health care facilities [@hulland2019travel; @weiss2020global] have generated significant interest and use[^1], and the city data set of Nelson et al. [@nelson2019suite] is available to R users through the widely-used `geodata` package [@geodata]. There is clear demand for these type of products.

[^1]: Collectively >1600 citations per Google Scholar at the 28th of January 2025.

Weiss et al. [@weiss2020global] made their code available as an R script to allow for reproduction and extension of their analyses (<https://malariaatlas.org/wp-content/uploads/2022/11/R_generic_accessibilty_mapping_script_2020-1.txt> ). To further enable extension of this work, here we have developed an R package based on that code to seamlessly calculate the travel time from any arbitrary set of locations.

Other R packages provide superficially similar though fundamentally different functionality. A gaggle of R packages provide interfaces to the [TravelTime.com](https://www.TravelTime.com) API [@traveltimeapi; @traveltimeR; @rtraveltime; @traveltime_gh]. The TravelTime.com platform provides travel time and routes between pairs of locations, and 'isochron' polygons --- areas reachable within a given time from a given location. The isochron polygons are most comparable to what `traveltime::calculate_travel_time()` calculates, though each isochron polygon is a single polygon calculated is for a single point location and specified maximum travel time, and the result provides a maximum reachable extent for a specified time, rather than a raster of gradation across a landscape for an arbitrary number of points as in `traveltime`. TravelTime.com cannot provide a single result surface for time to the nearest of a group of points, and continuous time scale without extensive repeated iteration for all combinations of time and points, plus additional calculation of the minimum value for each cell from all points. Furthermore, TravelTime.com requires access keys, a paid subscription beyond a short free period, and caps queries, which add considerable friction to the use of this resource.

With `traveltime`, we provide free and open source software to estimate travel time from any number of user-supplied locations, across a complete area of interest, and with convenient access to motorised or walking friction surfaces with global coverage.

# Example: walking from public transport in Singapore

In this example we will calculate the walking travel time from the nearest mass transit station across the island nation of Singapore --- specifically Mass Rapid Transit (MRT) and Light Rail Transit (LRT) stations --- and create a map of this.

## Prepare the data and friction surface

For this exercise, we need two items of data:

-   our area of interest --- in this case a map of Singapore, and
-   our points to calculate travel time from --- here the locations of Singapore's MRT and LRT stations.

We can download a national-level polygon boundary of Singapore from the GADM [@gadm] database using the `geodata` package [@geodata]. Here we download only the national boundary (`level = 0`) and at a low resolution (`resolution = 2`). Our boundary `singapore_shapefile` is a `SpatVector` class object.

```{r}
#| echo: true
#| label: get-basemap
library(terra)
library(geodata)

singapore_shapefile <- gadm(
  country = "Singapore",
  level = 0,
  path = tempdir(),
  resolution = 2
)

singapore_shapefile
```


The `stations` data set included in the `traveltime` package is a 563 row, 2 column `matrix` containing the longitude (`x`) and latitude (`y`) of all LRT and MRT station exits in Singapore from Land Transport Authority @singdata:

```{r}
#| label: show-stations
library(traveltime)
head(stations)
```

Now that we have the two items of data that we require, the next step is to prepare a friction surface for our area of interest. We will use the friction surface from Weiss et al. [@weiss2020global] that can be downloaded by `traveltime` with the function `get_friction_surface()`. We can pass in our basemap `singapore_shapefile`, a `SpatVector`, directly as the `extent`. We're interested in walking time from a station, so we'll download the walking friction surface by specifying `surface = "walk2020"`. (Alternatively, we could use `surface = "motor2020"` for motorised travel if that were of interest.) We're also only interested in walking *on land* so we then mask out areas outside of the land boundary in `singapore_shapefile`:

```{r}
#| label: download-friction-surface
#| echo: true
#| output: false
friction_singapore <- get_friction_surface(
    surface = "walk2020",
    extent = singapore_shapefile
  )|> 
  mask(singapore_shapefile)
```

Thus we have our friction surface as a `SpatRaster`:

```{r }
#| label: show-friction-surface-raster
friction_singapore
```

Below we plot the friction surface raster `friction_singapore`, with the vector boundary `singapore_shapefile` as a grey line, and `stations` as grey points (Figure @fig-data). `traveltime` takes resistance values of friction [@gdistance2017], so higher values of friction indicate more time travelling across a given cell. In this case walking friction is fairly uniform across the islands barring a few small inaccesible locations. More heterogeneity would be expected in less developed locations with fewer transport corridors.

```{r}
#| label: fig-data
#| echo: false
#| fig-cap: "Friction surface raster of Singapore, showing Singapore boundary
#|   in grey, and station locations as grey points."
library(tidyterra)
library(ggplot2)

ggplot() +
  geom_spatraster(
    data = friction_singapore
  ) +
  geom_spatvector(
    data = singapore_shapefile,
    fill = "transparent",
    col = "grey50"
  ) +
  geom_point(
    data = stations,
    aes(
      x = x,
      y = y
    ),
    col = "grey60",
    size = 0.5
  ) +
  scale_fill_viridis_c(
    option = "A",
    na.value = "transparent",
    direction = -1
  ) +
  labs(
    fill = "Resistance",
    x = element_blank(),
    y = element_blank()
  ) +
  theme_minimal()


```

## Calculate and plot the travel time

With all the data collected, the function `calculate_travel_time()` takes the friction surface `friction_singapore` and the points of interest in `stations`, and returns a `SpatRaster` of walking time in minutes to each cell from the nearest station:

```{r}
#| label: calculate-result
trave_time_singapore <- calculate_travel_time(
  friction_surface = friction_singapore,
  points = stations
)

trave_time_singapore
```

We present the resulting calculated travel times in Figure @fig-result where, as expected, the travel times are lowest near station exits (per Figure @fig-data) and progressively higher further away. Note that the results in `trave_time_singapore` include infinite values (`Inf`  above). In Figure @fig-data, the islands to the south and north-east are shown as filled cells, but unconnected with the mainland. The raster cells for these islands appear absent in Figure @fig-result. Because they are not connected to any cells with a station, the calculated travel time is infinite, and so these cells do not appear in Figure @fig-result.

```{r}
#| label: fig-result
#| echo: false
#| fig-cap: "Map of walking travel time in Singapore, in minutes from 
#|   nearest MRT or LRT station."
ggplot() +
  geom_spatraster(
    data = trave_time_singapore
  ) +
  scale_fill_viridis_c(
    option = "A",
    direction = -1,
    na.value = "transparent"
  ) +
  theme_minimal() +
  labs(fill = "Minutes") +
  geom_spatvector(
    data = singapore_shapefile,
    fill = "transparent",
    col = "grey20"
  )
```

# Opportunities for future development

The `traveltime` package is immediately suitable to a range of applications where travel to custom locations is of interest. Nonetheless, we see opportunities to build the package utility into the future through two mechanisms: (1) capability to better distribute a wider range friction surfaces, and (2) additional methods to handle large spatial extents.

Firstly, `traveltime` currently has access to walking and motorised friction surfaces for 2020, both at 30 arc-second resolution[^2]. Although the user can supply their own friction surface, we expect most applications will use these existing surfaces given the extensive work needed in creating new ones [@weiss2018global; @weiss2020global]. As landscapes are not dynamic, it may be useful to incorporate updated versions of these friction surfaces if and when they are available, though this is likely to occur first through `malariaAtlas`. Furthermore, although the resolution of these data is likely to be suitable for larger landscape foci, higher resolution data may be helpful for more locally focussed analyses. For instance, although the example here was chosen for it's simplicity and low computational demands, a ~1 km^2^ cell size is a relatively large area to walk across, and thus actual waking times may vary significantly within each cell. We underline however that a user can provide their own higher resolution friction surface at present if desired.

[^2]: Approximately 0.008333 decimal degrees, or just below 1 km$^2$ at the equator

At the other end of the scale, the calculations can require relatively large amounts of onboard memory for analyses over large landscapes (e.g. analyses over Africa required ~ 72 GB RAM). Developing methods to handle large landscapes either with less memory or via cloud resources would be helpful to make such analyses accessible to those without access to larger computing resources.

# Acknowledgements

This work was supported, in whole or in part, by the Bill & Melinda Gates Foundation [INV-021972]. The conclusions and opinions expressed in this work are those of the authors alone and shall not be attributed to the Foundation. Under the grant conditions of the Foundation, a Creative Commons Attribution 4.0 License has already been assigned to the Author Accepted Manuscript version that might arise from this submission. Please note works submitted as a preprint have not undergone a peer review process.


# References
