---
title: "`{traveltime}`: an R package to calculate walking and motorised travel time from user-specified locations"
format:
  #md: default
  html:
    keep-md: true
    fig-height: 4
    fig-align: center
    fig-format: png
    dpi: 300
tags: 
  - R
  - geographic information systems
  - spatial analysis
authors:
  - name: Gerard E Ryan
    orcid: 0000-0003-0183-7630
    corresponding: true
    affiliation: "1, 2"
  - name: Nick Tierney
    orcid: 0000-0003-1460-8722
    affiliation: "1, 3"
  - name: Nick Golding
    orcid: 0000-0001-8916-5570
    affiliation: "1, 3 "
  - name: Daniel Weiss
    orcid: 0000-0002-6175-5648
    affiliation: "1, 3"
affiliations:
 - name: The Kids Research Institute Australia, Nedlands 6009 WA, Australia
   index: 1
 - name: Melbourne School of Population and Global Health, University of Melbourne, 3010, VIC, Australia
   index: 2
 - name: Curtin University, Bentley, WA, Australia
   index: 3
date: In prep 2025
bibliography: paper.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

# Summary

Understanding and mapping the time to travel among locations is useful for many activities from urban planning [@zahavi1974traveltime] to public health [@weiss2020global] (@ref-tt_healthcare) and likely a myriad others. Here we present a software package --- `{traveltime}` --- written in and for the language R [@Rref]. `{traveltime}` enables a user to supply a set of geographic point locations and an extent of interest, to then calculate the motorised or walking travel time over that extent. The result is a raster of 30 arcsecond resolution (approximately 0.008333 decimal degrees, or just below 1 km$^2$ at the equator) where the value in each cell is the lowest travel time in minutes to any of the supplied point locations over the extent of interest (e.g., travel time from health care facilities @ref-tt_healthcare from @weiss2020global).

The work-flow requires two steps:

-   downloading a 'friction surface' for the area of interest, and then
-   calculating travel time over that surface for the points of interest.

`{traveltime}` provides a spatial interface using object classes from the `terra` package `[@terra]`. It accepts points as `matrix`, `data.frame`, or `SpatVector` class objects; and extents as `numeric`, `SpatExtent`, `SpatVector`, or `SpatRaster` objects; and returns the result as a `SpatRaster` object. The package uses `gdistance` [@gdistance2017] to calculate the minimum least-cost-distance for each cell from the points of interest. The travel time is calculated as movement over a 'friction surface' based-on the surfaces generated by @weiss2020global available via the `malariaAtlas` package [@pfeffer2018malariaatlas]. Rather than house and manipulate these surfaces independently, `{traveltime}` relies on `malariaAtlas` to download the surfaces for the extent of interest.

```{r ttexample,  include=FALSE}
library(terra)
library(malariaAtlas)

boundary_kh <- getShp(ISO = "KHM")

tt_kh <- getRaster(
  dataset_id = "Accessibility__202001_Global_Motorized_Travel_Time_to_Healthcare",
  shp = boundary_kh
)
```


```{r ttexample_image, echo=FALSE}
#| label: "fig-tt_healthcare"
#| fig-cap: "Existing surface of motorised travel time from healthcare facilities, exerpted to Cambodia (Weiss et al., 2020)"
library(ggplot2)
library(tidyterra)

ggplot() +
  geom_spatraster(
    data = tt_kh
  ) +
  scale_fill_viridis_c(
    option = "A",
    direction = -1,
    na.value = "transparent"
  ) +
  theme_minimal() +
  labs(fill = "minutes")
```

`{traveltime}` is available from [R-Universe](https://idem-lab.r-universe.dev/traveltime) and [GitHub](https://github.com/idem-lab/traveltime), and has reference documents at <https://idem-lab.github.io/traveltime/>. Although this article is intended to be the key reference for the `{traveltime}` package, we suggest citations of the package should be accompanied by citing the underlying work by @weiss2018global; @weiss2020global as well.

# Statement of need

Global maps of travel time to cities [@weiss2018global] and health care facilities [@weiss2020global] (@fig-tt_healthcare) have generated significant interest and use. Collectively @weiss2018global ; @weiss2020global have over 1300 citations (Google Scholar, at 10th December 2024), and the city data set is available to R users through the widely-used `geodata` package [@geodata]. There is clear demand for these type of products.

@weiss2020global and colleagues made their code available as an R script to allow for reproduction and extension of their analyses (<https://malariaatlas.org/wp-content/uploads/2022/11/R_generic_accessibilty_mapping_script_2020-1.txt> ). To further enable extension of this work, here we have developed an R package based on that code to seamlessly calculate the travel time from any arbitrary set of locations.

Other R packages produce superficially similar though fundamentally different functionality. A gaggle of R packages provide interfaces to the <https://www.TravelTime.com> API [@traveltimeapi; @traveltimeR; @rtraveltime; @traveltime_gh]. The TravelTime.com platform provides travel time and routes between pairs of locations, and 'isochron' polygons, which are areas reachable within a given time from a given location. The isochron polygons are most comparable to what the `{traveltime}` package calculates, though each calculation is for a single point location and specified maximum travel time, and the result provides a maximum reachable extent for a specified time, rather than gradation across cells. TravelTime.com cannot provide a single result surface for time to the nearest of a group of points, and continuous time scale without extensive repetitive iteration for all combinations of time and points, and additional calculations of the minimum value for each cell from all points. Furthermore, TravelTime.com requires access keys, a paid subscription beyond a short free period, and caps queries, which add considerable friction to the use.

With `{traveltime}`, we provide free and open source software to estimate motorised or walking travel time from any number of user-supplied locations, across a complete area of interest.

# Example: walking from public transport in Singapore

In this example we wish to calculate the walking travel time from the nearest mass transit station across the island nation of Singapore --- specifically MRT and LRT stations --- and create a map of this.

## Prepare the data and download friction surface

For this excercise, we need two items of data:

-   our extent of interest --- in this case a map of Singapore, and
-   our points to calculate travel time from --- here the locations of Singapore's MRT and LRT stations.

We can download a national-level polygon of Singapore from the GADM [@gadm] database using the `geodata` package [@geodata]. Here we download only the national boundary (`level = 0`) and at a low resolution (`resolution = 2`). Our boundary `sin` is a `SpatVector` class object.

```{r get basemap}
library(geodata)

sin <- gadm(
  country = "Singapore",
  level = 0,
  path = tempdir(),
  resolution = 2
)

sin
```

```{r plot basemap}
#| label: "fig-basemap"
#| fig-cap: "Area of interest: Singapore"

ggplot() +
  geom_spatvector(
    data = sin
  ) +
  scale_fill_manual(na.value = "transparent") +
  theme_minimal()
```

The the `stations` data set included in the `{traveltime}` package is a 563 \$\*\$ 2 `matrix` containing the longitude (x) and latitude (y) of all LRT and MRT station exits in Singapore from @singdata:2024.

```{r show stations}
library(traveltime)
head(stations)
```

Now that we have the two items of data that require, the next step is to download a friction surface for our area of interest. We can pass in our basemap `sin` (@fig-basemap), a `SpatVector`, directly as the `extent`. We're interested in walking time from a station, so we'll download the walking friction surface by specifying `surface = "walk2020"`. (Alternatively, we could use `surface = "motor2020"` for motorised travel if that were of interest.)

We're also only interested in walking *on land* so we mask out areas outside of `sin`, that are within the extent of the raster:

```{r  download friction surface, echo=TRUE, output=FALSE}
library(traveltime)

friction_singapore <- get_friction_surface(
    surface = "walk2020",
    extent = sin
  )|> 
  mask(sin)
```

Thus we have our friction surface as a `SpatRaster`:

```{r show friction surface raster }
friction_singapore
```

Below we plot the friction surface raster `friction_singapore`, with the vector boundary of `sin` as a dashed grey line, and `stations` as grey points @fig-data. Higher values of friction indicate more time travelling across a given cell.

```{r plot data}
#| label: "fig-data"
#| fig-cap: "Friction surface raster of Singapore, showing Singapore boundary in grey, and station locations as grey points"

library(tidyterra)
library(ggplot2)

ggplot() +
  geom_spatraster(
    data = friction_singapore
  ) +
  geom_spatvector(
    data = sin,
    fill = "transparent",
    col = "grey50"
  ) +
  geom_point(
    data = stations,
    aes(
      x = x,
      y = y
    ),
    col = "grey60",
    size = 0.5
  ) +
  scale_fill_viridis_c(
    option = "A",
    na.value = "transparent",
    direction = -1
  ) +
  labs(
    fill = "Friction",
    x = element_blank(),
    y = element_blank()
  ) +
  theme_minimal()


```

## Calculate and plot the travel time

With all the data collected, the function `calculate_travel_time` takes the friction surface `friction_singapore` and the locations of interest `stations`, and returns a `SpatRaster` of walking time in minutes to each cell from the nearest station as a `SpatRaster`:

```{r calculate result}
travel_time_sin <- calculate_travel_time(
  friction_surface = friction_singapore,
  points = stations
)

travel_time_sin
```

We present the resulting calculated travel times in @fig-result:

```{r plot result}
#| label: "fig-result"
#| fig-cap: "Map of walking travel time in Singapore, in minutes from nearest MRT or LRT station."

ggplot() +
  geom_spatraster(
    data = travel_time_sin
  ) +
  scale_fill_viridis_c(
    option = "A",
    direction = -1,
    na.value = "transparent"
  ) +
  theme_minimal() +
  labs(fill = "minutes") +
  geom_spatvector(
    data = sin,
    fill = "transparent",
    col = "grey20"
  )
```

Note that the above raster `travel_time_sin` includes infinite (`Inf`) values. In @fig-data, a number of islands to the south are shown as cells unconnected with the mainland. These raster cells for these islands appear absent in @fig-result. Because they are not connected, the calculated travel time is infinite, and so these cells do not appear in the plot @fig-result.

# Opportunities for future development

The `{traveltime}` package is immediately suitable to a range of applications where travel to custom locations of interest. Nonetheless, we see opportunities to build the package utility into the future through two mechanisms: capability to distribute more a wider range friction surfaces, and additional methods to handle large spatial extents.

Firstly, `{traveltime}` currently has access to friction surfaces for 2020, both at 30 arc-second resolution. As landscapes are not dynamic, it may be useful to incorporate updated versions of these friction surfaces if and when they are available, though this is likely to occur first through `malariaAtlas`. Furthermore, although the resolution of these data is likely to be suitable for larger landscape foci, higher resolution data may be helpful for more locally focussed analyses. For instance, although the example here was chosen for it's simplicity and low computational demands, a 5 km cell size is a relatively large area to walk across, and thus actual waking times are likley to vary significantly within each cell.

At the other end of the scale, the package can require relatively large amounts of onboard memory for analyses over large landscapes (e.g. one analyses over Africa required \~ 72 GB RAM). Developing methods to handle large landscapes either with less memory or via cloud resources would be helpful to make such analyses accessible to those without access to larger computing resources.

# Acknowledgements

GR is supported by the Gates Foundation grant for the Vector Atlas.


# References
